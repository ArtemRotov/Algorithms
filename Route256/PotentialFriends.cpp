/*
    Во многих социальных сетях у пользователей есть возможность указать других пользователей как своих друзей.
Помимо этого, часто существует система рекомендации друзей, которая показывает пользователям людей, с которыми
они знакомы косвенно (через кого-то из своих друзей), и предлагает добавить этих людей в список друзей.
Вам предстоит разработать систему рекомендации друзей.

В интересующей нас социальной сети n пользователей, каждому из которых присвоен уникальный id от 1 до n.
У каждого пользователя этой сети не более 5 друзей. Очевидно, ни один пользователь не является другом самому
себе, и если пользователь x в списке друзей у пользователя y, то и пользователь y входит в список друзей пользователя x.

Опишем, как должен формироваться список возможных друзей для каждого пользователя. Для пользователя x в список должны
входить такие пользователи y, что:

y не является другом x и не совпадает с x;
у пользователя y и у пользователя x есть хотя бы один общий друг;
не существует такого пользователя y′, который удовлетворяет первым двум ограничениям, и у которого строго больше общих
друзей с x, чем у y с x.
Иными словами, в список возможных друзей пользователя x входят все такие пользователи, не являющиеся его друзьями,
для которых количество общих друзей с x максимально. Обратите внимание, что список возможных друзей может быть пустым.

Вы должны написать программу, которая по заданной структуре социальной сети формирует списки возможных друзей для всех пользователей сети.
*/

#include <iostream>
#include <string>
#include <vector>
#include <unordered_map>
#include <algorithm>

int main()
{
    int all = 0;
    int pairs = 0;
    std::cin >> all >>pairs;

    std::unordered_map<int, std::vector<int>> uMap {};

    for (int i = 0; i < pairs; ++i)
    {
        int val1 = 0;
        int val2 = 0;
        std::cin >> val1 >> val2;

        uMap[val1].push_back(val2);
        uMap[val2].push_back(val1);
    }

    for (int i = 0; i < all; ++i)
    {
        int currNum = i+1;
        std::unordered_map<int,int> tmp {};
        std::unordered_map<int,int> tmp2 {};
        for (const auto &el : uMap[currNum])
        {
            tmp2[el]++;
            for (const auto &el1 : uMap[el])
                tmp[el1]++;
        }
        tmp[currNum] = 0;
        for (auto &p : tmp)
        {
            if (tmp2.count(p.first))
                p.second = 0;
        }

        auto el = std::max_element(tmp.begin(), tmp.end(), [](const auto &p1, const auto &p2)
                                       {    return p1.second < p2.second;   })->second;
        if (el == 0)
            std::cout << 0 << std::endl;
        else
        {
            std::vector<int> vec {};
            for (const auto &p : tmp)
            {
                if (p.second == el)
                    vec.push_back(p.first);
            }
            std::sort(vec.begin(),vec.end());
            for (const auto &num : vec)
                std::cout << num << ' ';
            std::cout << std::endl;
        }
    }

    return 0;
}
